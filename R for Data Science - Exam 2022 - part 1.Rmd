---
title: "R for Data Science - Exam - part 1"
author: "Andrea Melloncelli"
date: "6/8/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE 
)
```


## Dataset 

Use the `COVID19` dataset and work on the number of `deaths`.

- Instructions about how to get the data: https://covid19datahub.io/articles/api/r.html
- Dataset description: https://covid19datahub.io/articles/doc/data.html

```{r}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 
# install.packages("COVID19")
library(tidyverse)
library(COVID19)

x <- covid19(level = 1,  verbose = FALSE)
```


## Request

The goal is the exercise request as well as the readability and the robustness of your code. Therefore try to elaborate a code resilient to the increase of the number of countries as well as the increase of the amount of time, for example. 

### Exercise 1

Create a table to present the number of total `deaths` by country, sorted by the cumulative number of `deaths` in decreasing order.

```{r}
data = as_tibble(x)
data
names(data)

data%>%select(deaths) # ci sono tanti NA


# check for countries with no iso_name
data %>% filter(is.na(iso_alpha_3)) # 398
data %>% filter(is.na(iso_alpha_2)) # 398
data %>% filter(is.na(iso_alpha_2), is.na(iso_alpha_3)) # 398
# This means that iso_alpha_2 = NA iff iso_alpha_3 = 0
# Such countries can not be identified, hence we remove it from the analysis

data %>% filter(is.na(iso_alpha_3)) %>% select(administrative_area_level_1) %>% distinct()

# sol 1: using ISO3 codes

# a)
res1 = data %>% 
       filter(!is.na(iso_alpha_3)) %>% #remove unidentifiable countries
       group_by(iso_alpha_3) %>% summarise(total_deaths = sum(deaths)) %>%  #group and sum
       arrange(desc(total_deaths)) #sort
res1
View(res1)
# --> cos? facendo, se c'? un solo NA ritorna NA. infatti se provi a fare 1 + NA fa NA
# Ma questo non vuol dire che ci siano solo NA, ecco l'esempio per il belgio
belgium_deaths = data%>%filter(iso_alpha_3 == "BEL")%>%select(deaths)
any( !is.na(belgium_deaths)) #almeno un valore non ? NA



#b)
res2 = data %>% 
       filter(!is.na(iso_alpha_3)) %>% #remove unidentifiable countries
       group_by(iso_alpha_3) %>% summarise(total_deaths = sum(deaths, na.rm = T)) %>%  #group and sum
       arrange(desc(total_deaths)) #sort
res2
View(res2)
# --> risolve il problema di prima ma cos? se sono tutti NA il risultato ? 0. Brutto, non si distingue tra stati
#     con 0 morti e stati che non hanno comunicato i dati


#c) Definisco una funzione somma che fa quello che voglio io
my_sum = function(x){
  if(all( is.na(x)) )
    return (NA)
  else
    return (sum(x, na.rm = T))
}

x1 = c(1,1,1)
x2 = c(1,NA,1)
x3 = c(NA,NA,NA)
my_sum(x1)
my_sum(x2)
my_sum(x3)
# Casi tipo x4 = c(0,0,NA) rimangono ambigui, perch? non risultano morti ma non ? detto che non ce ne siano stati.
# uno stato potrebbe imbrogliare e dichiarare il numero di morti solo quando ? zero. 
# Facciamo una scelta sulla bont? delle persone e andiamo avanti. Per noi NA vuol dire che non c'era comunque
# volont? di nascondere il dato.

res = data %>% 
       filter(!is.na(iso_alpha_3)) %>% #remove unidentifiable countries
       group_by(iso_alpha_3) %>% summarise(total_deaths = my_sum(deaths)) %>%  #group and sum
       arrange(desc(total_deaths)) #sort
res

# sol 2: Add full variable names
iso = read_csv("countries_codes_and_coordinates.csv")
iso 

# Change name and select just country name and iso_3 code
get_iso_names = iso%>%rename(iso_alpha_3 = `Alpha-3 code`) %>% select(Country, iso_alpha_3) 
          


# Join tables
data %>% 
  filter(!is.na(iso_alpha_3)) %>% # Remove country with no name
  left_join(get_iso_names,"iso_alpha_3" ) %>% select(Country, iso_alpha_3) %>% #joint
  filter(is.na(Country)) %>%  summarise(unique(iso_alpha_3)) # check for NA

# Ci sono degli NA, vuol dire che la tabella che abbiamo trovato su internet non ? completa. 
# Li aggiungo a mano per semplicit?

# Complete Country names tibble
get_iso_names_extended = bind_rows(get_iso_names,
                          tibble(Country = c("SXM", "BES", "RKS", "CUW"), 
                                 iso_alpha_3 = c("SXM", "BES", "RKS", "CUW")) 
                         )
data %>% 
  filter(!is.na(iso_alpha_3)) %>% # Remove country with no name
  left_join(get_iso_names,"iso_alpha_3" ) %>% select(Country, iso_alpha_3)%>% #joint
  filter(is.na(Country)) %>%  summarise(unique(iso_alpha_3)) # check for NA
# No country is NA


# Solve exercise with country names
res_country = data %>% 
              filter(!is.na(iso_alpha_3)) %>% #remove unidentifiable countries
              group_by(iso_alpha_3) %>% summarise(total_deaths = my_sum(deaths)) %>% #group and sum
              left_join(get_iso_names_extended,"iso_alpha_3" ) %>% select(Country, iso_alpha_3 ,total_deaths) %>%
              arrange(desc(total_deaths))  %>%#sort            
              # Add country name. The length is different than before. There are no repeated values, some state
              # has been added
              distinct(iso_alpha_3, .keep_all = T) #remove duplicate rows
res_country

```

### Exercises 2.

Using the `COVID19` dataset, work on the number of `deaths`.

Aggregate data by month and use only 2020 data.

Compare the country different situations. Therefore organize the table as shown in the example below: with one row for each country (`country` the primary key of the table), sort the lines by the total deaths (i.e. `Total Deaths`) like in previous table, and show this quantity split on the time interval you chose. Therefore one more column for each period (i.e. one more column for each month) in chronological order from left to right (i.e. therefore column names will be `2020-01`, `2020-02`, `2020-03`, ...). 

Example of result:

```{r}
tibble(
  country = "ITA",
  `Total Deaths` = 4,
  `2020-01` = 0, 
  `2020-02` = 1, 
  `2020-03` = 3
)
```







```{r}
library(lubridate)

data = as_tibble(x)
data
names(data)


# Solution with extended names 
ex2 =
data %>% filter(!is.na(iso_alpha_3)) %>% #remove unidentifiable countries
         select(iso_alpha_3, date, deaths) %>%            # select relevant columns
         filter(year(date) == 2020 )   %>%           # select 2020 data only
         mutate(date_ym = format(floor_date(date, unit = "month"),"%Y/%m" ),
                country = iso_alpha_3) %>%    
          # round dates, only year and month are relevant
         group_by(country, date_ym) %>% summarise(death_per_month = sum(deaths)) %>% 
         # Compute number of deaths in each country for each month
         ungroup() %>%
         pivot_wider(names_from = date_ym, values_from = death_per_month) # put months as columns 
ex2


# Change names  (non serve piÃ¹)
new_dates = str_replace_all(names(ex2)[2:length(names(ex2))], pattern = "-", replace = "/") %>%
            str_trunc(7, ellipsis = "")



```

